<!DOCTYPE html>
<html lang="el">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>CyberChaos Neon</title>
  <style>
    :root {
      --neon-red: #ff003c;
      --neon-white: #ffffff;
      --bg-color: #000000;
    }
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      background: var(--bg-color);
      color: var(--neon-white);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      overflow: hidden;
      padding-top: calc(env(safe-area-inset-top, 0px) + 8px);
      padding-bottom: calc(env(safe-area-inset-bottom, 0px) + 8px);
    }
    .frame {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 12px;
      padding: 12px;
      border-radius: 16px;
      background: rgba(0,0,0,0.85);
      box-shadow: 0 0 30px rgba(255,0,60,.3);
      width: min(96vw, 540px);
      position: relative;
    }
    .hud {
      width: 100%;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
      margin-top: calc(env(safe-area-inset-top, 0px) + 8px);
    }
    .title {
      font-weight: 800;
      letter-spacing: .08em;
      color: var(--neon-white);
      text-shadow: 0 0 10px var(--neon-red);
      font-size: 14px;
    }
    .score {
      font-weight: 700;
      color: var(--neon-white);
      text-shadow: 0 0 10px var(--neon-red);
    }
    canvas {
      width: 100%;
      height: auto;
      max-height: 68vh;
      border-radius: 12px;
      background: var(--bg-color);
      image-rendering: pixelated;
      box-shadow: 0 0 24px rgba(255,0,60,.3);
      touch-action: none;
    }
    .joystick-wrap {
      width: 100%;
      display: flex;
      justify-content: center;
    }
    .joystick {
      position: relative;
      width: 120px;
      height: 120px;
      border-radius: 50%;
      background: radial-gradient(60% 60% at 50% 50%, rgba(255,255,255,.06), rgba(255,255,255,.02));
      box-shadow: inset 0 0 12px rgba(255,0,60,.25);
      touch-action: none;
    }
    .stick {
      position: absolute;
      width: 64px;
      height: 64px;
      border-radius: 50%;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      background: radial-gradient(circle at 30% 30%, rgba(255,255,255,.6), rgba(255,255,255,.2));
      box-shadow: 0 0 18px rgba(255,0,60,.35);
    }
    .hint {
      font-size: 12px;
      opacity: .7;
    }
    .pause-btn {
      position: absolute;
      top: calc(env(safe-area-inset-top, 0px) + 8px);
      right: 12px;
      padding: 6px 12px;
      background: rgba(255,0,60,0.2);
      color: var(--neon-white);
      border: 1px solid var(--neon-red);
      border-radius: 8px;
      cursor: pointer;
      text-shadow: 0 0 6px var(--neon-red);
      font-weight: bold;
      user-select: none;
    }
    .paused-overlay {
      position: absolute;
      inset: 0;
      display: flex;
      justify-content: center;
      align-items: center;
      background: rgba(0,0,0,0.5);
      color: var(--neon-white);
      font-size: 32px;
      font-weight: bold;
      text-shadow: 0 0 12px var(--neon-red);
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.2s ease;
    }
    .paused-overlay.show {
      opacity: 1;
    }
  </style>
</head>
<body>
  <div class="frame">
    <div class="hud">
      <div class="title">CYBERCHAOS</div>
      <div class="score">Score: <span id="score">0</span> | Level: <span id="level">1</span></div>
    </div>
    <button class="pause-btn" id="pauseBtn">Pause</button>
    <canvas id="game"></canvas>
    <div class="paused-overlay" id="pausedOverlay">PAUSED</div>
    <div class="joystick-wrap">
      <div class="joystick" id="joystick"><div class="stick" id="stick"></div></div>
    </div>
    <div class="hint">Swipe, μοχλός, χειριστήριο ή βελάκια.</div>
  </div>

  <script>
  /* ===== Config ===== */
  const ROWS=14, COLS=14;
  let STEP_MS=220; 
  const WALL=1, DOT=2, EMPTY=0, POWER=3;
  const COLORS={
    wall:'#ff003c', dot:'#ffffff', pac:'#ffffff', enemy:'#ff003c', power:'#ffaaaa', bg:'#000000'
  };

  /* ===== Levels (5 εύκολα και playable) ===== */
  const L1=[
  [1,1,1,1,1,1,1,1,1,1,1,1,1,1],
  [1,2,2,2,2,2,2,2,2,2,2,2,2,1],
  [1,2,1,1,2,1,1,1,1,2,1,1,2,1],
  [1,2,1,0,2,0,0,0,0,2,0,1,2,1],
  [1,2,2,2,2,2,2,2,2,2,2,2,2,1],
  [1,2,1,1,2,1,1,1,1,2,1,1,2,1],
  [1,2,0,0,2,2,3,2,2,2,0,0,2,1],
  [1,2,2,2,2,0,0,0,2,2,2,2,2,1],
  [1,2,1,1,2,2,2,2,2,2,1,1,2,1],
  [1,2,1,1,2,0,0,0,2,2,1,1,2,1],
  [1,2,2,2,2,2,2,2,2,2,2,2,2,1],
  [1,1,1,1,1,1,1,1,1,1,1,1,1,1],
  [1,1,1,1,1,1,1,1,1,1,1,1,1,1],
  [1,1,1,1,1,1,1,1,1,1,1,1,1,1]
  ];
  // Δημιουργούμε 4 παραλλαγές με μικρές αλλαγές
  const levels=[L1];
  for(let i=1;i<5;i++){
    let nl=JSON.parse(JSON.stringify(L1));
    nl[3][i+3]=1-i%2; nl[7][i+5]=1-(i%2);
    levels.push(nl);
  }

  /* ===== Canvas setup ===== */
  const canvas=document.getElementById('game');
  const ctx=canvas.getContext('2d');
  const scoreEl=document.getElementById('score');
  const levelEl=document.getElementById('level');
  const pauseBtn=document.getElementById('pauseBtn');
  const pausedOverlay=document.getElementById('pausedOverlay');

  function computeTile(){
    const maxW=document.querySelector('.frame').clientWidth-16;
    const maxH=Math.min(window.innerHeight*0.62,540);
    return Math.floor(Math.min(maxW/COLS, maxH/ROWS));
  }
  let TILE=computeTile();
  let dpr = Math.max(1, Math.floor(window.devicePixelRatio||1));
  function resizeCanvas(){
    TILE=computeTile();
    dpr=Math.max(1,Math.floor(window.devicePixelRatio||1));
    canvas.width=COLS*TILE*dpr; canvas.height=ROWS*TILE*dpr;
    canvas.style.width=(COLS*TILE)+"px"; canvas.style.height=(ROWS*TILE)+"px";
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  window.addEventListener('resize', resizeCanvas, {passive:true});

  /* ===== Entities ===== */
  let currentLevel=0;
  let layout;
  function setupLevel(lv){
    layout=clone(levels[lv]);
    pac.x=pac.px=1; pac.y=pac.py=1; pac.dir=0; pac.want=0;
    enemies.length=0;
    enemies.push({x:12,y:1,dir:2,px:12,py:1});
    if(lv>=1) enemies.push({x:12,y:10,dir:3,px:12,py:10});
  }
  const pac = { x:1, y:1, dir:0, want:0, px:1, py:1, power:0 };
  let score = 0;
  const enemies = [];

  /* ===== Input ===== */
  document.addEventListener('keydown', (e)=>{
    const map={ArrowRight:0,ArrowDown:1,ArrowLeft:2,ArrowUp:3,'d':0,'s':1,'a':2,'w':3,'D':0,'S':1,'A':2,'W':3};
    if(map[e.key]!==undefined) pac.want = map[e.key];
    if(e.key==='Enter') togglePause();
  }, {passive:true});

  /* Swipe gestures βελτιωμένα */
  let touchStartX=0, touchStartY=0, swiping=false;
  canvas.addEventListener('touchstart', e=>{
    const t=e.touches[0];
    touchStartX=t.clientX; touchStartY=t.clientY;
    swiping=true;
  },{passive:true});
  canvas.addEventListener('touchmove', e=>{
    if(!swiping) return;
    const t=e.touches[0];
    const dx=t.clientX-touchStartX;
    const dy=t.clientY-touchStartY;
    const adx=Math.abs(dx), ady=Math.abs(dy);
    if(Math.max(adx,ady)>20){
      if(adx>ady) pac.want=dx>0?0:2; else pac.want=dy>0?1:3;
      swiping=false;
    }
  },{passive:true});
  canvas.addEventListener('touchend', ()=>{swiping=false;},{passive:true});

  /* ===== Mechanics ===== */
  function canMove(x,y){ return layout[y] && layout[y][x] !== WALL; }

  function stepEntity(ent, isPlayer=false){
    ent.px = ent.x; ent.py = ent.y;
    let nx=ent.x, ny=ent.y;
    if(isPlayer){
      const tryDir=(d)=>{ let tx=nx,ty=ny; if(d===0)tx++; if(d===2)tx--; if(d===1)ty++; if(d===3)ty--; return canMove(tx,ty)?[tx,ty]:null; };
      const wantMove=tryDir(pac.want);
      if(wantMove){ ent.dir=pac.want; [nx,ny]=wantMove; }
      else { const keep=tryDir(ent.dir); if(keep) [nx,ny]=keep; }
      ent.x=nx; ent.y=ny;
      if(layout[ny][nx]===DOT){ layout[ny][nx]=EMPTY; score++; scoreEl.textContent=score; if(countDots()===0) nextLevel(); }
      else if(layout[ny][nx]===POWER){ layout[ny][nx]=EMPTY; pac.power=200; }
    } else {
      // Χαζό AI
      if(Math.random()<0.4){
        const dirs=[0,1,2,3];
        ent.dir = dirs[Math.floor(Math.random()*4)];
      }
      if(ent.dir===0) nx++; if(ent.dir===2) nx--; if(ent.dir===1) ny++; if(ent.dir===3) ny--;
      if(canMove(nx,ny)){ ent.x=nx; ent.y=ny; }
    }
  }

  function countDots(){
    let c=0; for(let y=0;y<ROWS;y++)for(let x=0;x<COLS;x++) if(layout[y][x]===DOT || layout[y][x]===POWER) c++;
    return c;
  }

  function nextLevel(){
    currentLevel = (currentLevel+1) % levels.length;
    setupLevel(currentLevel);
    levelEl.textContent = currentLevel+1;
    STEP_MS = Math.max(160, 220 - currentLevel*10);
  }

  function gameOver(){
    setupLevel(0); currentLevel=0; levelEl.textContent=1; STEP_MS=220;
    score=0; scoreEl.textContent=0;
  }

  /* ===== Rendering ===== */
  function draw(time=0, alpha=0){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    for(let y=0;y<ROWS;y++){
      for(let x=0;x<COLS;x++){
        const v=layout[y][x];
        if(v===WALL){
          ctx.save(); ctx.shadowColor=COLORS.wall; ctx.shadowBlur=12;
          ctx.fillStyle='#150000'; ctx.fillRect(x*TILE,y*TILE,TILE,TILE);
          ctx.strokeStyle=COLORS.wall; ctx.lineWidth=2; ctx.strokeRect(x*TILE+1,y*TILE+1,TILE-2,TILE-2);
          ctx.restore();
        } else if(v===DOT){
          ctx.save(); ctx.shadowColor=COLORS.dot; ctx.shadowBlur=8; ctx.fillStyle=COLORS.dot;
          ctx.beginPath(); ctx.arc(x*TILE+TILE/2,y*TILE+TILE/2,Math.max(2,TILE*0.08),0,Math.PI*2); ctx.fill();
          ctx.restore();
        } else if(v===POWER){
          ctx.save(); ctx.shadowColor=COLORS.power; ctx.shadowBlur=12; ctx.fillStyle=COLORS.power;
          ctx.beginPath(); ctx.arc(x*TILE+TILE/2,y*TILE+TILE/2,Math.max(4,TILE*0.15),0,Math.PI*2); ctx.fill();
          ctx.restore();
        }
      }
    }
    const rx = lerp(pac.px, pac.x, alpha) * TILE + TILE/2;
    const ry = lerp(pac.py, pac.y, alpha) * TILE + TILE/2;
    const mouth = 0.28 + 0.12*Math.abs(Math.sin(time*0.008));
    const start = mouth + pac.dir*Math.PI/2;
    const end   = (Math.PI*2) - mouth + pac.dir*Math.PI/2;
    ctx.save(); ctx.shadowColor=COLORS.pac; ctx.shadowBlur=14; ctx.fillStyle=COLORS.pac;
    ctx.beginPath(); ctx.moveTo(rx,ry); ctx.arc(rx,ry, TILE*0.42, start, end); ctx.closePath(); ctx.fill();
    if(pac.power>0){
      ctx.strokeStyle=COLORS.power;
      ctx.lineWidth=2;
      ctx.beginPath();
      ctx.arc(rx,ry,TILE*0.5,0,Math.PI*2);
      ctx.stroke();
    }
    ctx.restore();
    enemies.forEach((e,ei)=>{
      const ex = lerp(e.px,e.x,alpha)*TILE + TILE/2;
      const ey = lerp(e.py,e.y,alpha)*TILE + TILE/2;
      ctx.save(); ctx.shadowColor=COLORS.enemy; ctx.shadowBlur=14; ctx.fillStyle=COLORS.enemy;
      ctx.beginPath(); ctx.arc(ex,ey, TILE*0.4, 0, Math.PI*2); ctx.fill(); ctx.restore();
      if(Math.hypot((rx-ex),(ry-ey)) < TILE*0.6){
        if(pac.power>0){ enemies.splice(ei,1); score+=5; scoreEl.textContent=score; }
        else gameOver();
      }
    });
  }

  /* ===== Pause ===== */
  let paused=false;
  function togglePause(){
    paused=!paused;
    pausedOverlay.classList.toggle('show', paused);
  }
  pauseBtn.addEventListener('click', togglePause);

  /* ===== Game Loop ===== */
  let last=0, acc=0;
  function loop(ts){
    if(!last) last = ts;
    const dt = Math.min(50, ts - last);
    last = ts;
    if(!paused){
      acc += dt;
      while(acc >= STEP_MS){
        stepEntity(pac, true);
        enemies.forEach(e=>stepEntity(e,false));
        if(pac.power>0) pac.power--;
        acc -= STEP_MS;
      }
      const alpha = acc / STEP_MS;
      draw(ts, alpha);
    }
    requestAnimationFrame(loop);
  }

  /* ===== Utils ===== */
  function lerp(a,b,t){ return a + (b-a)*t; }
  function clone(x){ return JSON.parse(JSON.stringify(x)); }

  /* Init */
  setupLevel(0);
  resizeCanvas();
  requestAnimationFrame(loop);
  </script>
</body>
</html>
