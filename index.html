<!DOCTYPE html>
<html lang="el">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>CyberChaos Neon</title>
  <style>
    :root { --neon-red:#ff003c; --neon-white:#ffffff; --bg:#000000; }
    *{box-sizing:border-box;margin:0;padding:0}
    body{
      background:var(--bg); color:var(--neon-white);
      font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;
      display:flex; justify-content:center; align-items:center;
      min-height:100vh; overflow:hidden;
      padding-top:calc(env(safe-area-inset-top,0px)+8px);
      padding-bottom:calc(env(safe-area-inset-bottom,0px)+8px);
    }
    .frame{
      width:min(96vw, 560px); border-radius:16px; position:relative;
      background:rgba(0,0,0,.85); box-shadow:0 0 30px rgba(255,0,60,.3);
      padding:12px; display:flex; flex-direction:column; gap:12px;
    }

    /* ---------- HUD ---------- */
    .hud{
      width:100%; display:flex; justify-content:space-between; align-items:center; gap:10px;
      margin-top:calc(env(safe-area-inset-top,0px)+8px);
    }
    .title{ font-weight:900; letter-spacing:.12em; font-size:14px; color:#fff; text-shadow:0 0 10px var(--neon-red) }
    .hud-right{ display:flex; align-items:center; gap:12px }
    .stats{
      font-weight:800; font-variant-numeric:tabular-nums;
      text-shadow:0 0 8px rgba(255,255,255,.35);
    }
    .stats .label{ opacity:.95 }
    .stats .sep{ opacity:.6; margin:0 6px }
    .pausebtn{
      appearance:none; border:1px solid var(--neon-red);
      background:rgba(255,0,60,.18); color:#fff; padding:6px 12px; border-radius:10px;
      font-weight:800; letter-spacing:.04em; cursor:pointer;
      box-shadow:0 0 10px rgba(255,0,60,.25), inset 0 0 6px rgba(255,255,255,.08);
      user-select:none;
    }
    @media (max-width:420px){
      .hud-right{ flex-direction:column; align-items:flex-end; gap:6px }
      .stats{ font-size:13px }
    }

    /* ---------- Canvas & UI ---------- */
    .canvas-wrap{ position:relative }
    canvas{
      width:100%; height:auto; max-height:68vh; border-radius:12px;
      background:#000; image-rendering:pixelated; touch-action:none;
      box-shadow:0 0 24px rgba(255,0,60,.3);
    }
    .paused-overlay{
      position:absolute; inset:0; display:flex; align-items:center; justify-content:center;
      background:rgba(0,0,0,.5); color:#fff; font-size:28px; font-weight:900;
      text-shadow:0 0 12px var(--neon-red); opacity:0; pointer-events:none; transition:.2s ease;
      border-radius:12px;
    }
    .paused-overlay.show{ opacity:1 }

    .joystick-wrap{ width:100%; display:flex; justify-content:center }
    .joystick{ position:relative; width:120px; height:120px; border-radius:50%;
      background:radial-gradient(60% 60% at 50% 50%, rgba(255,255,255,.06), rgba(255,255,255,.02));
      box-shadow:inset 0 0 12px rgba(255,0,60,.25); touch-action:none;
    }
    .stick{ position:absolute; width:64px; height:64px; border-radius:50%;
      left:50%; top:50%; transform:translate(-50%,-50%);
      background:radial-gradient(circle at 30% 30%, rgba(255,255,255,.6), rgba(255,255,255,.2));
      box-shadow:0 0 18px rgba(255,0,60,.35);
    }
    .hint{font-size:12px; opacity:.7; text-align:center}
  </style>
</head>
<body>
  <div class="frame">
    <div class="hud">
      <div class="title">CYBERCHAOS</div>
      <div class="hud-right">
        <div class="stats">
          <span class="label">Score:</span> <span id="score">0</span>
          <span class="sep">|</span>
          <span class="label">Level:</span> <span id="level">1</span>
        </div>
        <button class="pausebtn" id="pauseBtn">Pause</button>
      </div>
    </div>

    <div class="canvas-wrap">
      <canvas id="game"></canvas>
      <div class="paused-overlay" id="pausedOverlay">PAUSED</div>
    </div>

    <div class="joystick-wrap">
      <div class="joystick" id="joystick"><div class="stick" id="stick"></div></div>
    </div>
    <div class="hint">Swipe, μοχλός, χειριστήριο ή βελάκια.</div>
  </div>

  <script>
  /* ===== Config ===== */
  const ROWS=14, COLS=14;
  let STEP_MS=220;
  const WALL=1, DOT=2, EMPTY=0, POWER=3;
  const COLORS={ wall:'#ff003c', dot:'#ffffff', pac:'#ffffff', enemy:'#ff003c', power:'#ffaaaa' };

  /* ===== Levels (5 εύκολα) ===== */
  const L1=[
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1],
    [1,2,2,2,2,2,2,2,2,2,2,2,2,1],
    [1,2,1,1,2,1,1,1,1,2,1,1,2,1],
    [1,2,1,0,2,0,0,0,0,2,0,1,2,1],
    [1,2,2,2,2,2,2,2,2,2,2,2,2,1],
    [1,2,1,1,2,1,1,1,1,2,1,1,2,1],
    [1,2,0,0,2,2,3,2,2,2,0,0,2,1],
    [1,2,2,2,2,0,0,0,2,2,2,2,2,1],
    [1,2,1,1,2,2,2,2,2,2,1,1,2,1],
    [1,2,1,1,2,0,0,0,2,2,1,1,2,1],
    [1,2,2,2,2,2,2,2,2,2,2,2,2,1],
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1],
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1],
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1]
  ];
  const levels=[L1]; for(let i=1;i<5;i++){ const nl=JSON.parse(JSON.stringify(L1)); nl[3][i+3]=1-i%2; nl[7][i+5]=1-(i%2); levels.push(nl); }

  /* ===== Canvas ===== */
  const canvas=document.getElementById('game');
  const ctx=canvas.getContext('2d');
  const scoreEl=document.getElementById('score');
  const levelEl=document.getElementById('level');
  const pauseBtn=document.getElementById('pauseBtn');
  const pausedOverlay=document.getElementById('pausedOverlay');

  function computeTile(){
    const maxW=document.querySelector('.frame').clientWidth-16;
    const maxH=Math.min(window.innerHeight*0.62,540);
    return Math.floor(Math.min(maxW/COLS, maxH/ROWS));
  }
  let TILE=computeTile(), dpr=Math.max(1, Math.floor(window.devicePixelRatio||1));
  function resizeCanvas(){
    TILE=computeTile(); dpr=Math.max(1,Math.floor(window.devicePixelRatio||1));
    canvas.width=COLS*TILE*dpr; canvas.height=ROWS*TILE*dpr;
    canvas.style.width=(COLS*TILE)+'px'; canvas.style.height=(ROWS*TILE)+'px';
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  addEventListener('resize', resizeCanvas, {passive:true});

  /* ===== Entities ===== */
  let currentLevel=0, layout;
  const pac={x:1,y:1,dir:0,want:0,px:1,py:1,power:0};
  let score=0; const enemies=[];
  function setupLevel(i){
    layout=JSON.parse(JSON.stringify(levels[i]));
    pac.x=pac.px=1; pac.y=pac.py=1; pac.dir=0; pac.want=0; pac.power=0;
    enemies.length=0; enemies.push({x:12,y:1,dir:2,px:12,py:1});
    if(i>=1) enemies.push({x:12,y:10,dir:3,px:12,py:10});
    levelEl.textContent=i+1;
  }

  /* ===== Input ===== */
  document.addEventListener('keydown',e=>{
    const map={ArrowRight:0,ArrowDown:1,ArrowLeft:2,ArrowUp:3,'d':0,'s':1,'a':2,'w':3,'D':0,'S':1,'A':2,'W':3};
    if(map[e.key]!==undefined) pac.want=map[e.key];
    if(e.key==='Enter') togglePause();
  },{passive:true});

  // Swipe (γρήγορο & σταθερό)
  let sx=0, sy=0, sw=false;
  canvas.addEventListener('touchstart',e=>{const t=e.touches[0]; sx=t.clientX; sy=t.clientY; sw=true;},{passive:true});
  canvas.addEventListener('touchmove',e=>{
    if(!sw) return; const t=e.touches[0]; const dx=t.clientX-sx, dy=t.clientY-sy;
    if(Math.max(Math.abs(dx),Math.abs(dy))>22){ pac.want = Math.abs(dx)>Math.abs(dy) ? (dx>0?0:2) : (dy>0?1:3); sw=false; }
  },{passive:true});
  canvas.addEventListener('touchend',()=>{sw=false;},{passive:true});

  // Joystick
  const joy=document.getElementById('joystick'), stick=document.getElementById('stick');
  const MAXR=44, DEAD=10; let jc=null;
  function jStart(e){const r=joy.getBoundingClientRect(); jc={x:r.left+r.width/2,y:r.top+r.height/2}; jMove(e);}
  function jMove(e){ if(!jc) return; const t=e.touches?e.touches[0]:e; let dx=t.clientX-jc.x, dy=t.clientY-jc.y;
    const len=Math.hypot(dx,dy), cl=Math.min(len,MAXR), nx=len?dx/len:0, ny=len?dy/len:0; dx=nx*cl; dy=ny*cl;
    stick.style.transform=`translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
    if(cl>DEAD) pac.want = Math.abs(dx)>Math.abs(dy)? (dx>0?0:2) : (dy>0?1:3);
  }
  function jEnd(){ jc=null; stick.style.transform='translate(-50%,-50%)'; }
  joy.addEventListener('touchstart',jStart,{passive:true});
  joy.addEventListener('touchmove', jMove,{passive:true});
  joy.addEventListener('touchend',  jEnd,{passive:true});
  joy.addEventListener('mousedown', jStart); addEventListener('mousemove',jMove); addEventListener('mouseup',jEnd);

  /* ===== Mechanics ===== */
  function canMove(x,y){ return layout[y] && layout[y][x]!==WALL; }
  function countLeft(){ let c=0; for(let y=0;y<ROWS;y++)for(let x=0;x<COLS;x++) if(layout[y][x]===DOT||layout[y][x]===POWER) c++; return c; }

  function step(ent,isPlayer=false){
    ent.px=ent.x; ent.py=ent.y; let nx=ent.x, ny=ent.y;
    if(isPlayer){
      const tryDir=d=>{let tx=nx,ty=ny; if(d===0)tx++; if(d===2)tx--; if(d===1)ty++; if(d===3)ty--; return canMove(tx,ty)?[tx,ty]:null;}
      const want=tryDir(pac.want);
      if(want){ ent.dir=pac.want; [nx,ny]=want; } else { const keep=tryDir(ent.dir); if(keep) [nx,ny]=keep; }
      ent.x=nx; ent.y=ny;
      const v=layout[ny][nx];
      if(v===DOT){ layout[ny][nx]=EMPTY; score+=1; scoreEl.textContent=score; if(countLeft()===0) nextLevel(); }
      else if(v===POWER){ layout[ny][nx]=EMPTY; pac.power=200; score+=3; scoreEl.textContent=score; if(countLeft()===0) nextLevel(); }
    } else {
      if(Math.random()<0.4){ ent.dir=[0,1,2,3][(Math.random()*4)|0]; }
      if(ent.dir===0) nx++; if(ent.dir===2) nx--; if(ent.dir===1) ny++; if(ent.dir===3) ny--;
      if(canMove(nx,ny)){ ent.x=nx; ent.y=ny; }
    }
  }

  function nextLevel(){
    currentLevel=(currentLevel+1)%levels.length;
    setupLevel(currentLevel);
    STEP_MS=Math.max(170, 220-currentLevel*10);
  }
  function gameOver(){ setupLevel(0); currentLevel=0; score=0; scoreEl.textContent=0; STEP_MS=220; }

  /* ===== Render ===== */
  function draw(time=0, alpha=0){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    for(let y=0;y<ROWS;y++)for(let x=0;x<COLS;x++){
      const v=layout[y][x];
      if(v===WALL){
        ctx.save(); ctx.shadowColor=COLORS.wall; ctx.shadowBlur=12;
        ctx.fillStyle='#150000'; ctx.fillRect(x*TILE,y*TILE,TILE,TILE);
        ctx.strokeStyle=COLORS.wall; ctx.lineWidth=2; ctx.strokeRect(x*TILE+1,y*TILE+1,TILE-2,TILE-2); ctx.restore();
      } else if(v===DOT){
        ctx.save(); ctx.shadowColor=COLORS.dot; ctx.shadowBlur=8; ctx.fillStyle=COLORS.dot;
        ctx.beginPath(); ctx.arc(x*TILE+TILE/2,y*TILE+TILE/2,Math.max(2,TILE*0.09),0,Math.PI*2); ctx.fill(); ctx.restore();
      } else if(v===POWER){
        ctx.save(); ctx.shadowColor=COLORS.power; ctx.shadowBlur=12; ctx.fillStyle=COLORS.power;
        ctx.beginPath(); ctx.arc(x*TILE+TILE/2,y*TILE+TILE/2,Math.max(4,TILE*0.16),0,Math.PI*2); ctx.fill(); ctx.restore();
      }
    }
    const rx=(pac.px+(pac.x-pac.px)*alpha)*TILE+TILE/2, ry=(pac.py+(pac.y-pac.py)*alpha)*TILE+TILE/2;
    const mouth=0.28+0.12*Math.abs(Math.sin(time*0.008)); const start=mouth+pac.dir*Math.PI/2; const end=(Math.PI*2)-mouth+pac.dir*Math.PI/2;
    ctx.save(); ctx.shadowColor=COLORS.pac; ctx.shadowBlur=14; ctx.fillStyle=COLORS.pac;
    ctx.beginPath(); ctx.moveTo(rx,ry); ctx.arc(rx,ry,TILE*0.42,start,end); ctx.closePath(); ctx.fill();

    if(pac.power>0){ // timer ring
      ctx.strokeStyle=COLORS.power; ctx.lineWidth=2; ctx.beginPath(); ctx.arc(rx,ry,TILE*0.5,0,Math.PI*2); ctx.stroke();
    }
    ctx.restore();

    enemies.forEach((e,ei)=>{
      const ex=(e.px+(e.x-e.px)*alpha)*TILE+TILE/2, ey=(e.py+(e.y-e.py)*alpha)*TILE+TILE/2;
      ctx.save(); ctx.shadowColor=COLORS.enemy; ctx.shadowBlur=14; ctx.fillStyle=COLORS.enemy;
      ctx.beginPath(); ctx.arc(ex,ey,TILE*0.4,0,Math.PI*2); ctx.fill(); ctx.restore();
      if(Math.hypot(rx-ex,ry-ey)<TILE*0.6){ if(pac.power>0){ enemies.splice(ei,1); score+=5; scoreEl.textContent=score; } else gameOver(); }
    });
  }

  /* ===== Pause ===== */
  let paused=false;
  function togglePause(){ paused=!paused; pausedOverlay.classList.toggle('show', paused); }
  pauseBtn.addEventListener('click', togglePause);

  /* ===== Loop ===== */
  let last=0, acc=0;
  function loop(ts){
    if(!last) last=ts; const dt=Math.min(50, ts-last); last=ts;
    if(!paused){
      acc+=dt;
      while(acc>=STEP_MS){
        step(pac,true); enemies.forEach(e=>step(e,false));
        if(pac.power>0) pac.power--;
        acc-=STEP_MS;
      }
      draw(ts, acc/STEP_MS);
    }
    requestAnimationFrame(loop);
  }

  /* ===== Init ===== */
  setupLevel(0); resizeCanvas(); requestAnimationFrame(loop);
  </script>
</body>
</html>
